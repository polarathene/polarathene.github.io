/* An animation specifically tailored for the `html-css.html` blog post */

/*
  This animation is activated on `:hover` as there is no nice way in CSS to
  pause between iterations and it gets irritating on repeat without a break.
*/

.student.astral-project:hover::after {
  content: var(--emoji-ghost);

  animation-duration: 2.5s;
  animation-iteration-count: infinite;

  /*
    Use an in-out easing, slowly starts and then speeds up near the end
    (which is useful as the path gets longer/wider).
  */
  animation-timing-function: var(--easing-easeInOutQuad);

  /* `width: 100%` is important for `position: absolute` fallback to horizontally center */
  width: 100%;
  /*
    Minor fix for `box-sizing: border-box` with `border-width` affecting `height: auto`,
    which in turn affects `transform: translateY(50%)` slightly making it off-center.
  */
  height: 100%;

  --ghost-offset: 50%;
  --ghost-scale-small:  translateY(var(--ghost-offset)) scale(0.4);
  --ghost-scale-normal: translateY(var(--ghost-offset)) scale(0.9);

  /*
    Not necessary in this case, but useful for debugging.
    Will fill to the parent - which should be `.student` if it sets a `position: relative`,
    otherwise for absolute it's presently the viewport dimensions.
  */
  /*
  background-color: aqua;
  width: 100%;
  transform: var(--ghost-scale-normal);
  animation-play-state: paused;
  */
}

/*
  Document flow base, only the animation fallback for `position: absolute`
  needs to tweak this for center alignment.
  Wasn't sure at the time which `position` would be appropriate,
  ended up writing both plus their fallback support, might as well keep both.

  `position: absolute` seems best for the `offset-path` version.
  `position: relative` seems easiest for the fallback version.
*/
.flow-absolute.astral-project {
  position: relative;
}
.flow-absolute.astral-project:hover::after {
  position: absolute;
}

.flow-relative.astral-project::after {
  position: relative;
  /* 
    Animation seems to require `display` set to `block` or `inline-block`.
    - `display: block` uses 100% width by default and doesn't interfere with
      other inline content.
    - Not required for `position: absolute`.
  */
  display: block;
}

/*
  WORKAROUND: Conditionally enabling via @support check.
  Safari presently lacks decent support for this approach.
*/
@supports (offset-path: path('')) and (offset-distance: 100%) {
  .student.astral-project:hover::after {
    animation-name: ghost-path, ghost-size, ghost-fade;

    /*
      The path co-ordinates are from the 0,0 (top-left) of an SVG document/viewbox?
      Enabling `offset-path` snaps the content to the start of the path from that 0,0 origin point,
      and uses the the contents `transform-origin` (default: center center)? (note: `text-align: center` is also in play),
      thus in this case it's moved to the top-left of the parent because this path roughly starts at 0,0.

      NOTE: `path()` value is sourced from the SVG asset `/assets/page/html-css/ghost-path.svg`
      Not responsive with scale, that'd need JS to update the path or use `url(#path-id)` with 
      an SVG path embedded into the HTML directly instead of CSS.
    */
    offset-path: path('M.41.399C.322-15.786 11.7-26.271 11.005-40.694c-1.403-19.536-25.952-40.9-24.9-65.091-.349-25.678 21.294-35.622 26.881-63.223');
    /* Used a fixed orientation, avoids content rotating along path */
    offset-rotate: 0deg;

    /*
      This would keep our content in place by moving the origin to top-left as well,
      but then our `transform: scale()` won't expand outwards from the center, which looks weird.
    */
    /* transform-origin: 0% 0%; */

    /*
      Required due to `offset-path` and the centered transform-origin (pivot point),
      bumps the content back to the proper centered position.
      `position: relative` offsets by 50% of the containing parents width from it's left-side.
      `position: absolute` offsets from the containing parents left edge, by 50% of the parents width.

       NOTE: `right: 0` or `right: 50%` might look odd for `position: absolute` if trying to grasp
       the difference, when width is not 100%, it helps to use `transform: translateX(50%);`
       to counter the additional offset from using `offest-path`.

       NOTE: `position: absolute` doesn't seem to need this, or the `width: 100%` to work
       correctly.
    */
    left: 50%;
  }
}

/* Fallback style will trigger when neither of these CSS properties are supported */
@supports not ((offset-path: path('')) or (offset-distance: 100%)) {
  .student.astral-project:hover::after {
    animation-name: ghost-path-fallback, ghost-size, ghost-fade;
  }

  /*
    Document flow specific fix
    Snap align the `width: 100%` item to the edge of the containing parent.
    Properly centers the content horizontally.
  */
  .flow-absolute.astral-project:hover::after {
    left: 0;
  }
}

/* Behold! The final parts of an effect that embarrassingly took over 5 hours to finish / polish */

/* Progress across the SVG path (squiggly line), and grow to normal size */
@keyframes ghost-path {
  0%   { offset-distance: 0%;   }
  100% { offset-distance: 100%; }
}

/* Moves straight up instead of zig-zagging, actually looks fine once I added scale */
/* Starts from center, and rises by 100% of the content height */
@keyframes ghost-path-fallback {
  0%   { top: -50%;    }
  100% { top: -150%; }
}

@keyframes ghost-size {
  0%   { transform: var(--ghost-scale-small);  }
  100% { transform: var(--ghost-scale-normal); }
}

/* Maybe an easing curve could simplify this? */
@keyframes ghost-fade {
  0% {
    opacity: 0;
  }
  50% {
    opacity: 0.7;
  }
  90% {
    opacity: 0;
  }
  100% {
    opacity: 0;
  }
}

/* 
  Using the `left`/`right`/`top`/`bottom` offsets:
  - Offsets are not bound to their containing parent, and may exceed it (eg: `top: 200%`).


  - `position: absolute`:
    The values represent offset distance from the containing parent edges/bounds.
    A value of 0 will snap/align the elements respective edge to the containing parents.

    When the dimensions `width`/`height` are `auto`, and both sides of an axis are set,
    the elements width/height stretches across that range within the containing parent.
    If the elements height or width exceed that range, then `left` and `bottom` values
    seem to be prioritized over `right` / `top`.

    If no edges are set (default `auto` for each), then the element should be in the
    same location in the document flow, but zero-sized, so other elements may overlap
    it within the DOM.


  - `position: relative`:
    The values offset relative to the edges of the content at it's original position within
    the document flow.

    Using `%` units, like the `width`/`height` dimensions will offset based on the parent
    elements dimensions. For pseudo-elements, this would be the non-pseudo element itself.

    Remember how common `display` types are sized:
    - `display: block` will default (`auto`) size it's width to the parents width.
    - `display: inline-block` auto sizes to it's content, unless explicit dimensions are set.
    - `display: inline` isn't a block element, so cannot manipulate the dimensions.
    - Be mindful of `text-align` being set on the containing parent (at least for pseudo-elements).
      For `display` values of `inline-block` / `inline`, it affects their horizontal alignment.
      This is separate from a child contents own `text-align` which affects it's own
      content (eg: inline text or inline-block) within it's own managed dimensions.


  - Also be aware that `auto` for dimensions includes any contributions from `border-width`
    when using `box-sizing: border-box` instead of `box-sizing: content-box`.
    This may cause content to overflow out bounds.
    - top/bottom/left/right, 100% is the containing parents width/height, ignoring border-width,
      whilst transforms translate 100% is based on the child contents dimension.
      This behaviour remains the same regardless of the box model (`box-sizing`).
      It is the bleed/overflow that contributed to the child contents `auto` dimension
      that affects the `transform` relying on % units, unless corrected by a non-auto value:
    - `width: 100%; height: 100%` will correct the overdraw/bleed from `background-color`,
      but `content` such as text will require `overflow: hidden` (for pseudo-element,
      this also clips/masks corners with the non-pseudo border-radus if any).
    - `display: block` seems to have `auto` act as `100%`, thus only needs `height: 100%`.
    - Could be avoided by sizing the element with enough width+height that also accounts
      for the border-width. `fit-content` or similar could be good for that:
      https://blog.logrocket.com/understanding-min-content-max-content-fit-content-css/
    - Alternatively, padding may also work instead of width/height
*/
